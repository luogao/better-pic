{"version":3,"sources":["../src/index.ts","../src/helpers.ts","utils/downloadCanvas.js","index.js"],"names":["ignore","const","defaultOpts","scale","src","opts","Object","console","warn","getImageData","img","Image","startsWith","crossOrigin","Promise","resolve","reject","onload","width","height","context","canvas","document","createElement","setAttribute","getContext","drawImage","errorHandler","Error","onerror","onabort","data","countMap","i","length","alpha","rgbComponents","Array","from","subarray","indexOf","undefined","color","join","count","values","sort","a","b","downloadFile","fileName","content","getImgSrc","aLink","blob","base64Img2Blob","download","href","URL","createObjectURL","click","dataUrl","toDataURL","code","parts","split","contentType","raw","window","atob","rawLength","uInt8Array","Uint8Array","charCodeAt","Blob","type","SLICE_LENGTH","canvasWidth","canvasHeight","showVisible","imgPositionTop","imgPositionLeft","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","imgToDraw","canvasForShow","getElementById","ctx","canvasBg","ctxBg","canvasShadow","ctxShadow","uploader","downloader","scaleControl","shadowVisibleControl","shadowColorControl","shadowBlurControl","shadowOffsetXControl","shadowOffsetYControl","container","shadowControl","outputCanvas","outputCtx","hanldeShadowVisibleChange","e","target","checked","showShadowSetting","hideShadowSetting","drawShadow","style","display","handleShadowOffsetXChange","Number","value","handleShadowOffsetYChange","handleShadowBlurChange","blur","handleScaleChange","drawImg","handleShadowColorChange","handleDownload","drawOutputCanvas","generate","logoMarker","date","Date","toLocaleDateString","initCanvas","clearRect","fillRect","handleUploaderChange","innerHTML","fileReader","FileReader","readAsDataURL","files","result","then","res","fullColors","colors","slice","forEach","item","node","cssText","appendChild","drawBg","Math","floor","random","fillStyle","addEventListener","nodeName","dataset"],"mappings":"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","file":"better-pic.b1b850ba.js","sourceRoot":"..","sourcesContent":["import {\n  getImageData,\n  getCounts\n} from './helpers'\n\ninterface Opts {\n  ignore?: string[]\n  scale?: number\n  skipTransparentPixels?: boolean\n}\n\nconst defaultOpts: Opts = {\n  ignore: [],\n  scale: 1\n}\n\nexport default async function (src: string, opts: Opts = defaultOpts): Promise<{ color: string, count: number }[] > {\n  opts = { ...defaultOpts, ...opts }\n\n  const {\n    ignore, // for example, to ignore white and black:  [ 'rgb(0,0,0)', 'rgb(255,255,255)' ]\n    scale   // 0 = best performance, lowest fidelity\n            // 1 = best fidelity, worst performance\n  } = opts\n\n  if (scale > 1 || scale <= 0) {\n    console.warn(`You set scale to ${scale}, which isn't between 0-1. This is either pointless (> 1) or a no-op (â‰¤ 0)`)\n  }\n\n  const data = await getImageData(src, scale)\n  return getCounts(data, ignore)\n}\n","\nexport const getContext = (width, height) => {\n  const canvas = document.createElement('canvas')\n  canvas.setAttribute('width', width)\n  canvas.setAttribute('height', height)\n  return canvas.getContext('2d')\n}\n\nexport const getImageData = (src: string, scale: number = 1): Promise<Uint8ClampedArray> => {\n  const img = new Image()\n\n  // Can't set cross origin to be anonymous for data url's\n  // https://github.com/mrdoob/three.js/issues/1305\n  if (!src.startsWith('data')) img.crossOrigin = 'Anonymous'\n\n  return new Promise((resolve, reject) => {\n    img.onload = function () {\n      const width = img.width * scale\n      const height = img.height * scale\n      const context = getContext(width, height)\n      context.drawImage(img, 0, 0, width, height)\n\n      const { data } = context.getImageData(0, 0, width, height)\n      resolve(data)\n    }\n\n    const errorHandler = () => reject(new Error('An error occurred attempting to load image'))\n\n    img.onerror = errorHandler\n    img.onabort = errorHandler\n    img.src = src\n  })\n}\n\nexport const getCounts = (data: Uint8ClampedArray, ignore: string[]): [] => {\n  const countMap = {}\n\n  for (let i = 0; i < data.length; i += 4 /* 4 gives us r, g, b, and a*/) {\n    let alpha: number = data[i + 3]\n    // skip FULLY transparent pixels\n    if (alpha === 0) continue\n\n    let rgbComponents: number[] = Array.from(data.subarray(i, i + 3))\n\n    // skip undefined data\n    if (rgbComponents.indexOf(undefined) !== -1) continue\n\n    let color: string = alpha && alpha !== 255\n      ? `rgba(${[...rgbComponents, alpha].join(',')})`\n      : `rgb(${rgbComponents.join(',')})`\n\n    // skip colors in the ignore list\n    if (ignore.indexOf(color) !== -1) continue\n\n    if (countMap[color]) {\n      countMap[color].count++\n    } else {\n      countMap[color] = { color, count: 1 }\n    }\n  }\n\n  const counts = Object.values(countMap) as []\n  return counts.sort((a: any, b: any) => b.count - a.count)\n}\n","/**\n *\n * @param {String} fileName Named the pic you'd like\n * @param {HTMLElement} canvas the canvas object you want to donwload from\n */\n\nexport default function downloadFile(fileName, canvas) {\n  const content = getImgSrc(canvas)\n  const aLink = document.createElement('a')\n  const blob = base64Img2Blob(content) //new Blob([content]);\n  aLink.download = fileName\n  aLink.href = URL.createObjectURL(blob)\n  aLink.click()\n}\n\nfunction getImgSrc(canvas) {\n  const dataUrl = canvas.toDataURL('image/png')\n  return dataUrl\n}\n\nfunction base64Img2Blob(code) {\n  const parts = code.split(';base64,')\n  const contentType = parts[0].split(':')[1]\n  const raw = window.atob(parts[1])\n  const rawLength = raw.length\n  const uInt8Array = new Uint8Array(rawLength)\n\n  for (let i = 0; i < rawLength; ++i) {\n    uInt8Array[i] = raw.charCodeAt(i)\n  }\n\n  return new Blob([uInt8Array], { type: contentType })\n}\n","import './index.css'\nimport analyze from 'rgbaster'\nimport downloadFile from './utils/downloadCanvas'\n\nconst SLICE_LENGTH = -1\nlet scale = 0.9\nlet canvasWidth = 0\nlet canvasHeight = 0\nlet showVisible = false\n\nlet imgPositionTop = 0\nlet imgPositionLeft = 0\nlet shadowColor = 'rgba(0,0,0,0.6)'\nlet shadowBlur = 100\nlet shadowOffsetX = 100\nlet shadowOffsetY = 100\n\nlet imgToDraw = null\n\nconst canvasForShow = document.getElementById('forshow')\nconst ctx = canvasForShow.getContext('2d')\n\nconst canvasBg = document.getElementById('bg')\nconst ctxBg = canvasBg.getContext('2d')\n\nconst canvasShadow = document.getElementById('shadow')\nconst ctxShadow = canvasShadow.getContext('2d')\n\nconst uploader = document.getElementById('uploader')\nconst downloader = document.getElementById('downloader')\nconst scaleControl = document.getElementById('img-scale')\nconst shadowVisibleControl = document.getElementById('shadow-visible')\nconst shadowColorControl = document.getElementById('shadow-color')\nconst shadowBlurControl = document.getElementById('shadow-blur')\nconst shadowOffsetXControl = document.getElementById('shadow-offset-x')\nconst shadowOffsetYControl = document.getElementById('shadow-offset-y')\nconst container = document.getElementById('color-container')\nconst shadowControl = document.getElementById('shadow-control')\n\nconst outputCanvas = document.createElement('canvas')\nconst outputCtx = outputCanvas.getContext('2d')\n\nuploader.addEventListener('change', handleUploaderChange)\ndownloader.addEventListener('click', handleDownload)\nscaleControl.addEventListener('change', handleScaleChange)\nshadowVisibleControl.addEventListener('change', hanldeShadowVisibleChange)\nshadowColorControl.addEventListener('change', handleShadowColorChange)\nshadowBlurControl.addEventListener('change', handleShadowBlurChange)\nshadowOffsetXControl.addEventListener('input', handleShadowOffsetXChange)\nshadowOffsetYControl.addEventListener('input', handleShadowOffsetYChange)\n\nfunction hanldeShadowVisibleChange(e) {\n  showVisible = e.target.checked\n  if (showVisible) {\n    showShadowSetting()\n  } else {\n    hideShadowSetting()\n  }\n  drawShadow()\n}\n\nfunction showShadowSetting() {\n  shadowControl.style.display = 'flex'\n}\nfunction hideShadowSetting() {\n  shadowControl.style.display = 'none'\n}\n\nfunction handleShadowOffsetXChange(e) {\n  shadowOffsetX = Number(e.target.value)\n  drawShadow()\n}\n\nfunction handleShadowOffsetYChange(e) {\n  shadowOffsetY = Number(e.target.value)\n  drawShadow()\n}\n\nfunction handleShadowBlurChange(e) {\n  const blur = Number(e.target.value)\n  shadowBlur = blur\n  drawShadow()\n}\n\nfunction handleScaleChange(e) {\n  scale = Number(e.target.value)\n  drawImg(imgToDraw)\n}\n\nfunction handleShadowColorChange(e) {\n  shadowColor = e.target.value\n  drawShadow()\n}\n\nfunction handleDownload() {\n  drawOutputCanvas()\n  downloadFile(generate(), outputCanvas)\n}\n\nfunction generate() {\n  const logoMarker = 'BP'\n  const date = new Date().toLocaleDateString()\n  return `${logoMarker}-${date}`\n}\n\nfunction initCanvas() {\n  canvasForShow.width = canvasBg.width = canvasShadow.width = outputCanvas.width = canvasWidth\n  canvasForShow.height = canvasBg.height = canvasShadow.height = outputCanvas.height = canvasHeight\n}\n\nfunction drawShadow() {\n  ctxShadow.clearRect(0, 0, canvasWidth, canvasHeight)\n  if (showVisible) {\n    ctxShadow.shadowColor = shadowColor\n    ctxShadow.shadowBlur = shadowBlur\n    ctxShadow.shadowOffsetX = shadowOffsetX\n    ctxShadow.shadowOffsetY = shadowOffsetY\n    ctxShadow.fillRect(imgPositionLeft, imgPositionTop, canvasWidth * scale, canvasHeight * scale)\n  }\n}\n\nfunction drawImg(img) {\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n  imgPositionLeft = (canvasWidth - canvasWidth * scale) / 2\n  imgPositionTop = (canvasHeight - canvasHeight * scale) / 2\n  ctx.drawImage(img, imgPositionLeft, imgPositionTop, canvasWidth * scale, canvasHeight * scale)\n  drawShadow()\n}\n\nfunction handleUploaderChange() {\n  container.innerHTML = 'Loading Color Data ...'\n  const fileReader = new FileReader()\n  fileReader.readAsDataURL(this.files[0])\n  fileReader.onload = function(e) {\n    const img = new Image()\n    img.src = e.target.result\n    imgToDraw = img\n    img.onload = function(e) {\n      const { width, height } = e.target\n      canvasWidth = width\n      canvasHeight = height\n\n      initCanvas()\n      drawImg(imgToDraw)\n\n      analyze(img.src, { scale: 0.1 }).then(res => {\n        const fullColors = res\n        const colors = fullColors.slice(0, SLICE_LENGTH)\n        container.innerHTML = ''\n        colors.forEach(item => {\n          const node = document.createElement('span')\n          node.setAttribute('data-color', item.color)\n          node.style.cssText = `width: 50px;height:50px;background-color: ${item.color}`\n          container.appendChild(node)\n        })\n\n        drawBg(colors[Math.floor(Math.random() * colors.length)].color)\n      })\n    }\n  }\n}\n\ncontainer.addEventListener('click', function(e) {\n  const target = e.target\n  if (target.nodeName === 'SPAN') {\n    drawBg(target.dataset.color)\n  }\n})\n\nfunction drawBg(color) {\n  ctxBg.clearRect(0, 0, canvasWidth, canvasHeight)\n  ctxBg.fillStyle = color\n  ctxBg.fillRect(0, 0, canvasWidth, canvasHeight)\n}\n\nfunction drawOutputCanvas() {\n  outputCtx.clearRect(0, 0, canvasWidth, canvasHeight)\n  outputCtx.drawImage(canvasBg, 0, 0, canvasWidth, canvasHeight)\n  showVisible && outputCtx.drawImage(canvasShadow, 0, 0, canvasWidth, canvasHeight)\n  outputCtx.drawImage(canvasForShow, 0, 0, canvasWidth, canvasHeight)\n}\n"]}